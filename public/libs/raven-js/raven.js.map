{"version":3,"sources":["raven.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"raven.js","sourcesContent":["/*! Raven.js 3.1.0 (d781478) | github.com/getsentry/raven-js */\r\n\r\n/*\r\n * Includes TraceKit\r\n * https://github.com/getsentry/TraceKit\r\n *\r\n * Copyright 2016 Matt Robenolt and other contributors\r\n * Released under the BSD license\r\n * https://github.com/getsentry/raven-js/blob/master/LICENSE\r\n *\r\n */\r\n\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Raven = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nfunction RavenConfigError(message) {\r\n    this.name = 'RavenConfigError';\r\n    this.message = message;\r\n}\r\nRavenConfigError.prototype = new Error();\r\nRavenConfigError.prototype.constructor = RavenConfigError;\r\n\r\nmodule.exports = RavenConfigError;\r\n\r\n},{}],2:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar wrapMethod = function(console, level, callback) {\r\n    var originalConsoleLevel = console[level];\r\n    var originalConsole = console;\r\n\r\n    if (!(level in console)) {\r\n        return;\r\n    }\r\n\r\n    var sentryLevel = level === 'warn'\r\n        ? 'warning'\r\n        : level;\r\n\r\n    console[level] = function () {\r\n        var args = [].slice.call(arguments);\r\n\r\n        var msg = '' + args.join(' ');\r\n        var data = {level: sentryLevel, logger: 'console', extra: {'arguments': args}};\r\n        callback && callback(msg, data);\r\n\r\n        // this fails for some browsers. :(\r\n        if (originalConsoleLevel) {\r\n            // IE9 doesn't allow calling apply on console functions directly\r\n            // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193\r\n            Function.prototype.apply.call(\r\n                originalConsoleLevel,\r\n                originalConsole,\r\n                args\r\n            );\r\n        }\r\n    };\r\n};\r\n\r\nmodule.exports = {\r\n    wrapMethod: wrapMethod\r\n};\r\n\r\n},{}],3:[function(_dereq_,module,exports){\r\n/*global XDomainRequest:false*/\r\n'use strict';\r\n\r\nvar TraceKit = _dereq_(6);\r\nvar RavenConfigError = _dereq_(1);\r\nvar utils = _dereq_(5);\r\n\r\nvar isFunction = utils.isFunction;\r\nvar isUndefined = utils.isUndefined;\r\nvar isError = utils.isError;\r\nvar isEmptyObject = utils.isEmptyObject;\r\nvar hasKey = utils.hasKey;\r\nvar joinRegExp = utils.joinRegExp;\r\nvar each = utils.each;\r\nvar objectMerge = utils.objectMerge;\r\nvar truncate = utils.truncate;\r\nvar urlencode = utils.urlencode;\r\nvar uuid4 = utils.uuid4;\r\nvar htmlTreeAsString = utils.htmlTreeAsString;\r\nvar parseUrl = utils.parseUrl;\r\nvar isString = utils.isString;\r\n\r\nvar wrapConsoleMethod = _dereq_(2).wrapMethod;\r\n\r\nvar dsnKeys = 'source protocol user pass host port path'.split(' '),\r\n    dsnPattern = /^(?:(\\w+):)?\\/\\/(?:(\\w+)(:\\w+)?@)?([\\w\\.-]+)(?::(\\d+))?(\\/.*)/;\r\n\r\nfunction now() {\r\n    return +new Date();\r\n}\r\n\r\n// First, check for JSON support\r\n// If there is no JSON, we no-op the core features of Raven\r\n// since JSON is required to encode the payload\r\nfunction Raven() {\r\n    this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);\r\n    // Raven can run in contexts where there's no document (react-native)\r\n    this._hasDocument = typeof document !== 'undefined';\r\n    this._lastCapturedException = null;\r\n    this._lastEventId = null;\r\n    this._globalServer = null;\r\n    this._globalKey = null;\r\n    this._globalProject = null;\r\n    this._globalContext = {};\r\n    this._globalOptions = {\r\n        logger: 'javascript',\r\n        ignoreErrors: [],\r\n        ignoreUrls: [],\r\n        whitelistUrls: [],\r\n        includePaths: [],\r\n        crossOrigin: 'anonymous',\r\n        collectWindowErrors: true,\r\n        maxMessageLength: 0,\r\n        stackTraceLimit: 50\r\n    };\r\n    this._ignoreOnError = 0;\r\n    this._isRavenInstalled = false;\r\n    this._originalErrorStackTraceLimit = Error.stackTraceLimit;\r\n    // capture references to window.console *and* all its methods first\r\n    // before the console plugin has a chance to monkey patch\r\n    this._originalConsole = window.console || {};\r\n    this._originalConsoleMethods = {};\r\n    this._plugins = [];\r\n    this._startTime = now();\r\n    this._wrappedBuiltIns = [];\r\n    this._breadcrumbs = [];\r\n    this._breadcrumbLimit = 20;\r\n    this._lastCapturedEvent = null;\r\n    this._keypressTimeout;\r\n    this._location = window.location;\r\n    this._lastHref = this._location && this._location.href;\r\n\r\n    for (var method in this._originalConsole) {  // eslint-disable-line guard-for-in\r\n      this._originalConsoleMethods[method] = this._originalConsole[method];\r\n    }\r\n}\r\n\r\n/*\r\n * The core Raven singleton\r\n *\r\n * @this {Raven}\r\n */\r\n\r\nRaven.prototype = {\r\n    // Hardcode version string so that raven source can be loaded directly via\r\n    // webpack (using a build step causes webpack #1617). Grunt verifies that\r\n    // this value matches package.json during build.\r\n    //   See: https://github.com/getsentry/raven-js/issues/465\r\n    VERSION: '3.1.0',\r\n\r\n    debug: false,\r\n\r\n    TraceKit: TraceKit, // alias to TraceKit\r\n\r\n    /*\r\n     * Configure Raven with a DSN and extra options\r\n     *\r\n     * @param {string} dsn The public Sentry DSN\r\n     * @param {object} options Optional set of of global options [optional]\r\n     * @return {Raven}\r\n     */\r\n    config: function(dsn, options) {\r\n        var self = this;\r\n\r\n        if (this._globalServer) {\r\n                this._logDebug('error', 'Error: Raven has already been configured');\r\n            return this;\r\n        }\r\n        if (!dsn) return this;\r\n\r\n        // merge in options\r\n        if (options) {\r\n            each(options, function(key, value){\r\n                // tags and extra are special and need to be put into context\r\n                if (key === 'tags' || key === 'extra') {\r\n                    self._globalContext[key] = value;\r\n                } else {\r\n                    self._globalOptions[key] = value;\r\n                }\r\n            });\r\n        }\r\n\r\n        var uri = this._parseDSN(dsn),\r\n            lastSlash = uri.path.lastIndexOf('/'),\r\n            path = uri.path.substr(1, lastSlash);\r\n\r\n        this._dsn = dsn;\r\n\r\n        // \"Script error.\" is hard coded into browsers for errors that it can't read.\r\n        // this is the result of a script being pulled in from an external domain and CORS.\r\n        this._globalOptions.ignoreErrors.push(/^Script error\\.?$/);\r\n        this._globalOptions.ignoreErrors.push(/^Javascript error: Script error\\.? on line 0$/);\r\n\r\n        // join regexp rules into one big rule\r\n        this._globalOptions.ignoreErrors = joinRegExp(this._globalOptions.ignoreErrors);\r\n        this._globalOptions.ignoreUrls = this._globalOptions.ignoreUrls.length ? joinRegExp(this._globalOptions.ignoreUrls) : false;\r\n        this._globalOptions.whitelistUrls = this._globalOptions.whitelistUrls.length ? joinRegExp(this._globalOptions.whitelistUrls) : false;\r\n        this._globalOptions.includePaths = joinRegExp(this._globalOptions.includePaths);\r\n\r\n        this._globalKey = uri.user;\r\n        this._globalSecret = uri.pass && uri.pass.substr(1);\r\n        this._globalProject = uri.path.substr(lastSlash + 1);\r\n\r\n        this._globalServer = this._getGlobalServer(uri);\r\n\r\n        this._globalEndpoint = this._globalServer +\r\n            '/' + path + 'api/' + this._globalProject + '/store/';\r\n\r\n        TraceKit.collectWindowErrors = !!this._globalOptions.collectWindowErrors;\r\n\r\n        // return for chaining\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Installs a global window.onerror error handler\r\n     * to capture and report uncaught exceptions.\r\n     * At this point, install() is required to be called due\r\n     * to the way TraceKit is set up.\r\n     *\r\n     * @return {Raven}\r\n     */\r\n    install: function() {\r\n        var self = this;\r\n        if (this.isSetup() && !this._isRavenInstalled) {\r\n            TraceKit.report.subscribe(function () {\r\n                self._handleOnErrorStackInfo.apply(self, arguments);\r\n            });\r\n            this._wrapBuiltIns();\r\n\r\n            // Install all of the plugins\r\n            this._drainPlugins();\r\n\r\n            this._isRavenInstalled = true;\r\n        }\r\n\r\n        Error.stackTraceLimit = this._globalOptions.stackTraceLimit;\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Wrap code within a context so Raven can capture errors\r\n     * reliably across domains that is executed immediately.\r\n     *\r\n     * @param {object} options A specific set of options for this context [optional]\r\n     * @param {function} func The callback to be immediately executed within the context\r\n     * @param {array} args An array of arguments to be called with the callback [optional]\r\n     */\r\n    context: function(options, func, args) {\r\n        if (isFunction(options)) {\r\n            args = func || [];\r\n            func = options;\r\n            options = undefined;\r\n        }\r\n\r\n        return this.wrap(options, func).apply(this, args);\r\n    },\r\n\r\n    /*\r\n     * Wrap code within a context and returns back a new function to be executed\r\n     *\r\n     * @param {object} options A specific set of options for this context [optional]\r\n     * @param {function} func The function to be wrapped in a new context\r\n     * @param {function} func A function to call before the try/catch wrapper [optional, private]\r\n     * @return {function} The newly wrapped functions with a context\r\n     */\r\n    wrap: function(options, func, _before) {\r\n        var self = this;\r\n        // 1 argument has been passed, and it's not a function\r\n        // so just return it\r\n        if (isUndefined(func) && !isFunction(options)) {\r\n            return options;\r\n        }\r\n\r\n        // options is optional\r\n        if (isFunction(options)) {\r\n            func = options;\r\n            options = undefined;\r\n        }\r\n\r\n        // At this point, we've passed along 2 arguments, and the second one\r\n        // is not a function either, so we'll just return the second argument.\r\n        if (!isFunction(func)) {\r\n            return func;\r\n        }\r\n\r\n        // We don't wanna wrap it twice!\r\n        try {\r\n            if (func.__raven__) {\r\n                return func;\r\n            }\r\n        } catch (e) {\r\n            // Just accessing the __raven__ prop in some Selenium environments\r\n            // can cause a \"Permission denied\" exception (see raven-js#495).\r\n            // Bail on wrapping and return the function as-is (defers to window.onerror).\r\n            return func;\r\n        }\r\n\r\n        // If this has already been wrapped in the past, return that\r\n        if (func.__raven_wrapper__ ){\r\n            return func.__raven_wrapper__ ;\r\n        }\r\n\r\n        function wrapped() {\r\n            var args = [], i = arguments.length,\r\n                deep = !options || options && options.deep !== false;\r\n\r\n            if (_before && isFunction(_before)) {\r\n                _before.apply(this, arguments);\r\n            }\r\n\r\n            // Recursively wrap all of a function's arguments that are\r\n            // functions themselves.\r\n            while(i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];\r\n\r\n            try {\r\n                return func.apply(this, args);\r\n            } catch(e) {\r\n                self._ignoreNextOnError();\r\n                self.captureException(e, options);\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        // copy over properties of the old function\r\n        for (var property in func) {\r\n            if (hasKey(func, property)) {\r\n                wrapped[property] = func[property];\r\n            }\r\n        }\r\n        wrapped.prototype = func.prototype;\r\n\r\n        func.__raven_wrapper__ = wrapped;\r\n        // Signal that this function has been wrapped already\r\n        // for both debugging and to prevent it to being wrapped twice\r\n        wrapped.__raven__ = true;\r\n        wrapped.__inner__ = func;\r\n\r\n        return wrapped;\r\n    },\r\n\r\n    /*\r\n     * Uninstalls the global error handler.\r\n     *\r\n     * @return {Raven}\r\n     */\r\n    uninstall: function() {\r\n        TraceKit.report.uninstall();\r\n\r\n        this._restoreBuiltIns();\r\n\r\n        Error.stackTraceLimit = this._originalErrorStackTraceLimit;\r\n        this._isRavenInstalled = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Manually capture an exception and send it over to Sentry\r\n     *\r\n     * @param {error} ex An exception to be logged\r\n     * @param {object} options A specific set of options for this error [optional]\r\n     * @return {Raven}\r\n     */\r\n    captureException: function(ex, options) {\r\n        // If not an Error is passed through, recall as a message instead\r\n        if (!isError(ex)) return this.captureMessage(ex, options);\r\n\r\n        // Store the raw exception object for potential debugging and introspection\r\n        this._lastCapturedException = ex;\r\n\r\n        // TraceKit.report will re-raise any exception passed to it,\r\n        // which means you have to wrap it in try/catch. Instead, we\r\n        // can wrap it here and only re-raise if TraceKit.report\r\n        // raises an exception different from the one we asked to\r\n        // report on.\r\n        try {\r\n            var stack = TraceKit.computeStackTrace(ex);\r\n            this._handleStackInfo(stack, options);\r\n        } catch(ex1) {\r\n            if(ex !== ex1) {\r\n                throw ex1;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Manually send a message to Sentry\r\n     *\r\n     * @param {string} msg A plain message to be captured in Sentry\r\n     * @param {object} options A specific set of options for this message [optional]\r\n     * @return {Raven}\r\n     */\r\n    captureMessage: function(msg, options) {\r\n        // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an\r\n        // early call; we'll error on the side of logging anything called before configuration since it's\r\n        // probably something you should see:\r\n        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(msg)) {\r\n            return;\r\n        }\r\n\r\n        // Fire away!\r\n        this._send(\r\n            objectMerge({\r\n                message: msg + ''  // Make sure it's actually a string\r\n            }, options)\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    captureBreadcrumb: function (obj) {\r\n        var crumb = objectMerge({\r\n            timestamp: now() / 1000\r\n        }, obj);\r\n\r\n        this._breadcrumbs.push(crumb);\r\n        if (this._breadcrumbs.length > this._breadcrumbLimit) {\r\n            this._breadcrumbs.shift();\r\n        }\r\n    },\r\n\r\n    addPlugin: function(plugin /*arg1, arg2, ... argN*/) {\r\n        var pluginArgs = Array.prototype.slice.call(arguments, 1);\r\n\r\n        this._plugins.push([plugin, pluginArgs]);\r\n        if (this._isRavenInstalled) {\r\n            this._drainPlugins();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Set/clear a user to be sent along with the payload.\r\n     *\r\n     * @param {object} user An object representing user data [optional]\r\n     * @return {Raven}\r\n     */\r\n    setUserContext: function(user) {\r\n        // Intentionally do not merge here since that's an unexpected behavior.\r\n        this._globalContext.user = user;\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Merge extra attributes to be sent along with the payload.\r\n     *\r\n     * @param {object} extra An object representing extra data [optional]\r\n     * @return {Raven}\r\n     */\r\n    setExtraContext: function(extra) {\r\n        this._mergeContext('extra', extra);\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Merge tags to be sent along with the payload.\r\n     *\r\n     * @param {object} tags An object representing tags [optional]\r\n     * @return {Raven}\r\n     */\r\n    setTagsContext: function(tags) {\r\n        this._mergeContext('tags', tags);\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Clear all of the context.\r\n     *\r\n     * @return {Raven}\r\n     */\r\n    clearContext: function() {\r\n        this._globalContext = {};\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Get a copy of the current context. This cannot be mutated.\r\n     *\r\n     * @return {object} copy of context\r\n     */\r\n    getContext: function() {\r\n        // lol javascript\r\n        return JSON.parse(JSON.stringify(this._globalContext));\r\n    },\r\n\r\n    /*\r\n     * Set release version of application\r\n     *\r\n     * @param {string} release Typically something like a git SHA to identify version\r\n     * @return {Raven}\r\n     */\r\n    setRelease: function(release) {\r\n        this._globalOptions.release = release;\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Set the dataCallback option\r\n     *\r\n     * @param {function} callback The callback to run which allows the\r\n     *                            data blob to be mutated before sending\r\n     * @return {Raven}\r\n     */\r\n    setDataCallback: function(callback) {\r\n        this._globalOptions.dataCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Set the shouldSendCallback option\r\n     *\r\n     * @param {function} callback The callback to run which allows\r\n     *                            introspecting the blob before sending\r\n     * @return {Raven}\r\n     */\r\n    setShouldSendCallback: function(callback) {\r\n        this._globalOptions.shouldSendCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Override the default HTTP transport mechanism that transmits data\r\n     * to the Sentry server.\r\n     *\r\n     * @param {function} transport Function invoked instead of the default\r\n     *                             `makeRequest` handler.\r\n     *\r\n     * @return {Raven}\r\n     */\r\n    setTransport: function(transport) {\r\n        this._globalOptions.transport = transport;\r\n\r\n        return this;\r\n    },\r\n\r\n    /*\r\n     * Get the latest raw exception that was captured by Raven.\r\n     *\r\n     * @return {error}\r\n     */\r\n    lastException: function() {\r\n        return this._lastCapturedException;\r\n    },\r\n\r\n    /*\r\n     * Get the last event id\r\n     *\r\n     * @return {string}\r\n     */\r\n    lastEventId: function() {\r\n        return this._lastEventId;\r\n    },\r\n\r\n    /*\r\n     * Determine if Raven is setup and ready to go.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    isSetup: function() {\r\n        if (!this._hasJSON) return false;  // needs JSON support\r\n        if (!this._globalServer) {\r\n            if (!this.ravenNotConfiguredError) {\r\n              this.ravenNotConfiguredError = true;\r\n              this._logDebug('error', 'Error: Raven has not been configured.');\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    afterLoad: function () {\r\n        // TODO: remove window dependence?\r\n\r\n        // Attempt to initialize Raven on load\r\n        var RavenConfig = window.RavenConfig;\r\n        if (RavenConfig) {\r\n            this.config(RavenConfig.dsn, RavenConfig.config).install();\r\n        }\r\n    },\r\n\r\n    showReportDialog: function (options) {\r\n        if (!window.document) // doesn't work without a document (React native)\r\n            return;\r\n\r\n        options = options || {};\r\n\r\n        var lastEventId = options.eventId || this.lastEventId();\r\n        if (!lastEventId) {\r\n            throw new RavenConfigError('Missing eventId');\r\n        }\r\n\r\n        var dsn = options.dsn || this._dsn;\r\n        if (!dsn) {\r\n            throw new RavenConfigError('Missing DSN');\r\n        }\r\n\r\n        var encode = encodeURIComponent;\r\n        var qs = '';\r\n        qs += '?eventId=' + encode(lastEventId);\r\n        qs += '&dsn=' + encode(dsn);\r\n\r\n        var user = options.user || this._globalContext.user;\r\n        if (user) {\r\n            if (user.name)  qs += '&name=' + encode(user.name);\r\n            if (user.email) qs += '&email=' + encode(user.email);\r\n        }\r\n\r\n        var globalServer = this._getGlobalServer(this._parseDSN(dsn));\r\n\r\n        var script = document.createElement('script');\r\n        script.async = true;\r\n        script.src = globalServer + '/api/embed/error-page/' + qs;\r\n        (document.head || document.body).appendChild(script);\r\n    },\r\n\r\n    /**** Private functions ****/\r\n    _ignoreNextOnError: function () {\r\n        var self = this;\r\n        this._ignoreOnError += 1;\r\n        setTimeout(function () {\r\n            // onerror should trigger before setTimeout\r\n            self._ignoreOnError -= 1;\r\n        });\r\n    },\r\n\r\n    _triggerEvent: function(eventType, options) {\r\n        // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it\r\n        var evt, key;\r\n\r\n        if (!this._hasDocument)\r\n            return;\r\n\r\n        options = options || {};\r\n\r\n        eventType = 'raven' + eventType.substr(0,1).toUpperCase() + eventType.substr(1);\r\n\r\n        if (document.createEvent) {\r\n            evt = document.createEvent('HTMLEvents');\r\n            evt.initEvent(eventType, true, true);\r\n        } else {\r\n            evt = document.createEventObject();\r\n            evt.eventType = eventType;\r\n        }\r\n\r\n        for (key in options) if (hasKey(options, key)) {\r\n            evt[key] = options[key];\r\n        }\r\n\r\n        if (document.createEvent) {\r\n            // IE9 if standards\r\n            document.dispatchEvent(evt);\r\n        } else {\r\n            // IE8 regardless of Quirks or Standards\r\n            // IE9 if quirks\r\n            try {\r\n                document.fireEvent('on' + evt.eventType.toLowerCase(), evt);\r\n            } catch(e) {\r\n                // Do nothing\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wraps addEventListener to capture UI breadcrumbs\r\n     * @param evtName the event name (e.g. \"click\")\r\n     * @returns {Function}\r\n     * @private\r\n     */\r\n    _breadcrumbEventHandler: function(evtName) {\r\n        var self = this;\r\n        return function (evt) {\r\n            // reset keypress timeout; e.g. triggering a 'click' after\r\n            // a 'keypress' will reset the keypress debounce so that a new\r\n            // set of keypresses can be recorded\r\n            self._keypressTimeout = null;\r\n\r\n            // It's possible this handler might trigger multiple times for the same\r\n            // event (e.g. event propagation through node ancestors). Ignore if we've\r\n            // already captured the event.\r\n            if (self._lastCapturedEvent === evt)\r\n                return;\r\n\r\n            self._lastCapturedEvent = evt;\r\n            var elem = evt.target;\r\n\r\n            var target;\r\n\r\n            // try/catch htmlTreeAsString because it's particularly complicated, and\r\n            // just accessing the DOM incorrectly can throw an exception in some circumstances.\r\n            try {\r\n                target = htmlTreeAsString(elem);\r\n            } catch (e) {\r\n                target = '<unknown>';\r\n            }\r\n\r\n            self.captureBreadcrumb({\r\n                category: 'ui.' + evtName, // e.g. ui.click, ui.input\r\n                message: target\r\n            });\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Wraps addEventListener to capture keypress UI events\r\n     * @returns {Function}\r\n     * @private\r\n     */\r\n    _keypressEventHandler: function() {\r\n        var self = this,\r\n            debounceDuration = 1000; // milliseconds\r\n\r\n        // TODO: if somehow user switches keypress target before\r\n        //       debounce timeout is triggered, we will only capture\r\n        //       a single breadcrumb from the FIRST target (acceptable?)\r\n\r\n        return function (evt) {\r\n            var target = evt.target,\r\n                tagName = target && target.tagName;\r\n\r\n            // only consider keypress events on actual input elements\r\n            // this will disregard keypresses targeting body (e.g. tabbing\r\n            // through elements, hotkeys, etc)\r\n            if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA')\r\n                return;\r\n\r\n            // record first keypress in a series, but ignore subsequent\r\n            // keypresses until debounce clears\r\n            var timeout = self._keypressTimeout;\r\n            if (!timeout) {\r\n                self._breadcrumbEventHandler('input')(evt);\r\n            }\r\n            clearTimeout(timeout);\r\n            self._keypressTimeout = setTimeout(function () {\r\n               self._keypressTimeout = null;\r\n            }, debounceDuration);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Captures a breadcrumb of type \"navigation\", normalizing input URLs\r\n     * @param to the originating URL\r\n     * @param from the target URL\r\n     * @private\r\n     */\r\n    _captureUrlChange: function(from, to) {\r\n        var parsedLoc = parseUrl(this._location.href);\r\n        var parsedTo = parseUrl(to);\r\n        var parsedFrom = parseUrl(from);\r\n\r\n        // because onpopstate only tells you the \"new\" (to) value of location.href, and\r\n        // not the previous (from) value, we need to track the value of the current URL\r\n        // state ourselves\r\n        this._lastHref = to;\r\n\r\n        // Use only the path component of the URL if the URL matches the current\r\n        // document (almost all the time when using pushState)\r\n        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)\r\n            to = parsedTo.relative;\r\n        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)\r\n            from = parsedFrom.relative;\r\n\r\n        this.captureBreadcrumb({\r\n            category: 'navigation',\r\n            data: {\r\n                to: to,\r\n                from: from\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Install any queued plugins\r\n     */\r\n    _wrapBuiltIns: function() {\r\n        var self = this;\r\n\r\n        function fill(obj, name, replacement, noUndo) {\r\n            var orig = obj[name];\r\n            obj[name] = replacement(orig);\r\n            if (!noUndo) {\r\n                self._wrappedBuiltIns.push([obj, name, orig]);\r\n            }\r\n        }\r\n\r\n        function wrapTimeFn(orig) {\r\n            return function (fn, t) { // preserve arity\r\n                // Make a copy of the arguments to prevent deoptimization\r\n                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\r\n                var args = new Array(arguments.length);\r\n                for(var i = 0; i < args.length; ++i) {\r\n                    args[i] = arguments[i];\r\n                }\r\n                var originalCallback = args[0];\r\n                if (isFunction(originalCallback)) {\r\n                    args[0] = self.wrap(originalCallback);\r\n                }\r\n\r\n                // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\r\n                // also supports only two arguments and doesn't care what this is, so we\r\n                // can just call the original function directly.\r\n                if (orig.apply) {\r\n                    return orig.apply(this, args);\r\n                } else {\r\n                    return orig(args[0], args[1]);\r\n                }\r\n            };\r\n        }\r\n\r\n        function wrapEventTarget(global) {\r\n            var proto = window[global] && window[global].prototype;\r\n            if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\r\n                fill(proto, 'addEventListener', function(orig) {\r\n                    return function (evtName, fn, capture, secure) { // preserve arity\r\n                        try {\r\n                            if (fn && fn.handleEvent) {\r\n                                fn.handleEvent = self.wrap(fn.handleEvent);\r\n                            }\r\n                        } catch (err) {\r\n                            // can sometimes get 'Permission denied to access property \"handle Event'\r\n                        }\r\n\r\n\r\n                        // TODO: more than just click\r\n                        var before;\r\n                        if (global === 'EventTarget' || global === 'Node') {\r\n                            if (evtName === 'click'){\r\n                                before = self._breadcrumbEventHandler(evtName);\r\n                            } else if (evtName === 'keypress') {\r\n                                before = self._keypressEventHandler();\r\n                            }\r\n                        }\r\n                        return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);\r\n                    };\r\n                });\r\n                fill(proto, 'removeEventListener', function (orig) {\r\n                    return function (evt, fn, capture, secure) {\r\n                        fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__  : fn);\r\n                        return orig.call(this, evt, fn, capture, secure);\r\n                    };\r\n                });\r\n            }\r\n        }\r\n\r\n        function wrapProp(prop, xhr) {\r\n            if (prop in xhr && isFunction(xhr[prop])) {\r\n                fill(xhr, prop, function (orig) {\r\n                    return self.wrap(orig);\r\n                }, true /* noUndo */); // don't track filled methods on XHR instances\r\n            }\r\n        }\r\n\r\n        fill(window, 'setTimeout', wrapTimeFn);\r\n        fill(window, 'setInterval', wrapTimeFn);\r\n        if (window.requestAnimationFrame) {\r\n            fill(window, 'requestAnimationFrame', function (orig) {\r\n                return function (cb) {\r\n                    return orig(self.wrap(cb));\r\n                };\r\n            });\r\n        }\r\n\r\n        // Capture breadcrubms from any click that is unhandled / bubbled up all the way\r\n        // to the document. Do this before we instrument addEventListener.\r\n        if (this._hasDocument) {\r\n            if (document.addEventListener) {\r\n                document.addEventListener('click', self._breadcrumbEventHandler('click'));\r\n                document.addEventListener('keypress', self._keypressEventHandler());\r\n            }\r\n            else {\r\n                // IE8 Compatibility\r\n                document.attachEvent('onclick', self._breadcrumbEventHandler('click'));\r\n                document.attachEvent('onkeypress', self._keypressEventHandler());\r\n            }\r\n        }\r\n\r\n        // event targets borrowed from bugsnag-js:\r\n        // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666\r\n        var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\r\n        for (var i = 0; i < eventTargets.length; i++) {\r\n            wrapEventTarget(eventTargets[i]);\r\n        }\r\n\r\n        if ('XMLHttpRequest' in window) {\r\n            var xhrproto = XMLHttpRequest.prototype;\r\n            fill(xhrproto, 'open', function(origOpen) {\r\n                return function (method, url) { // preserve arity\r\n\r\n                    // if Sentry key appears in URL, don't capture\r\n                    if (isString(url) && url.indexOf(self._globalKey) === -1) {\r\n                        this.__raven_xhr = {\r\n                            method: method,\r\n                            url: url,\r\n                            status_code: null\r\n                        };\r\n                    }\r\n\r\n                    return origOpen.apply(this, arguments);\r\n                };\r\n            });\r\n\r\n            fill(xhrproto, 'send', function(origSend) {\r\n                return function (data) { // preserve arity\r\n                    var xhr = this;\r\n\r\n                    function onreadystatechangeHandler() {\r\n                        if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {\r\n                            try {\r\n                                // touching statusCode in some platforms throws\r\n                                // an exception\r\n                                xhr.__raven_xhr.status_code = xhr.status;\r\n                            } catch (e) { /* do nothing */ }\r\n                            self.captureBreadcrumb({\r\n                                type: 'http',\r\n                                category: 'xhr',\r\n                                data: xhr.__raven_xhr\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    var props = ['onload', 'onerror', 'onprogress'];\r\n                    for (var j = 0; j < props.length; j++) {\r\n                        wrapProp(props[j], xhr);\r\n                    }\r\n\r\n                    if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {\r\n                        fill(xhr, 'onreadystatechange', function (orig) {\r\n                            return self.wrap(orig, undefined, onreadystatechangeHandler);\r\n                        }, true /* noUndo */);\r\n                    } else {\r\n                        // if onreadystatechange wasn't actually set by the page on this xhr, we\r\n                        // are free to set our own and capture the breadcrumb\r\n                        xhr.onreadystatechange = onreadystatechangeHandler;\r\n                    }\r\n\r\n                    return origSend.apply(this, arguments);\r\n                };\r\n            });\r\n        }\r\n\r\n        // record navigation (URL) changes\r\n        if ('history' in window && history.pushState) {\r\n            // TODO: remove onpopstate handler on uninstall()\r\n            var oldOnPopState = window.onpopstate;\r\n            window.onpopstate = function () {\r\n                var currentHref = self._location.href;\r\n                self._captureUrlChange(self._lastHref, currentHref);\r\n\r\n                if (oldOnPopState) {\r\n                    return oldOnPopState.apply(this, arguments);\r\n                }\r\n            };\r\n\r\n            fill(history, 'pushState', function (origPushState) {\r\n                // note history.pushState.length is 0; intentionally not declaring\r\n                // params to preserve 0 arity\r\n                return function(/* state, title, url */) {\r\n                    var url = arguments.length > 2 ? arguments[2] : undefined;\r\n\r\n                    // url argument is optional\r\n                    if (url) {\r\n                        // coerce to string (this is what pushState does)\r\n                        self._captureUrlChange(self._lastHref, url + '');\r\n                    }\r\n\r\n                    return origPushState.apply(this, arguments);\r\n                };\r\n            });\r\n        }\r\n\r\n        // console\r\n        var consoleMethodCallback = function (msg, data) {\r\n            self.captureBreadcrumb({\r\n                message: msg,\r\n                level: data.level,\r\n                category: 'console'\r\n            });\r\n        };\r\n\r\n        if ('console' in window && console.log) {\r\n            each(['debug', 'info', 'warn', 'error', 'log'], function (_, level) {\r\n                wrapConsoleMethod(console, level, consoleMethodCallback);\r\n            });\r\n        }\r\n\r\n        var $ = window.jQuery || window.$;\r\n        if ($ && $.fn && $.fn.ready) {\r\n            fill($.fn, 'ready', function (orig) {\r\n                return function (fn) {\r\n                    return orig.call(this, self.wrap(fn));\r\n                };\r\n            });\r\n        }\r\n    },\r\n\r\n    _restoreBuiltIns: function () {\r\n        // restore any wrapped builtins\r\n        var builtin;\r\n        while (this._wrappedBuiltIns.length) {\r\n            builtin = this._wrappedBuiltIns.shift();\r\n\r\n            var obj = builtin[0],\r\n              name = builtin[1],\r\n              orig = builtin[2];\r\n\r\n            obj[name] = orig;\r\n        }\r\n    },\r\n\r\n    _drainPlugins: function() {\r\n        var self = this;\r\n\r\n        // FIX ME TODO\r\n        each(this._plugins, function(_, plugin) {\r\n            var installer = plugin[0];\r\n            var args = plugin[1];\r\n            installer.apply(self, [self].concat(args));\r\n        });\r\n    },\r\n\r\n    _parseDSN: function(str) {\r\n        var m = dsnPattern.exec(str),\r\n            dsn = {},\r\n            i = 7;\r\n\r\n        try {\r\n            while (i--) dsn[dsnKeys[i]] = m[i] || '';\r\n        } catch(e) {\r\n            throw new RavenConfigError('Invalid DSN: ' + str);\r\n        }\r\n\r\n        if (dsn.pass && !this._globalOptions.allowSecretKey) {\r\n            throw new RavenConfigError('Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key');\r\n        }\r\n\r\n        return dsn;\r\n    },\r\n\r\n    _getGlobalServer: function(uri) {\r\n        // assemble the endpoint from the uri pieces\r\n        var globalServer = '//' + uri.host +\r\n            (uri.port ? ':' + uri.port : '');\r\n\r\n        if (uri.protocol) {\r\n            globalServer = uri.protocol + ':' + globalServer;\r\n        }\r\n        return globalServer;\r\n    },\r\n\r\n    _handleOnErrorStackInfo: function() {\r\n        // if we are intentionally ignoring errors via onerror, bail out\r\n        if (!this._ignoreOnError) {\r\n            this._handleStackInfo.apply(this, arguments);\r\n        }\r\n    },\r\n\r\n    _handleStackInfo: function(stackInfo, options) {\r\n        var self = this;\r\n        var frames = [];\r\n\r\n        if (stackInfo.stack && stackInfo.stack.length) {\r\n            each(stackInfo.stack, function(i, stack) {\r\n                var frame = self._normalizeFrame(stack);\r\n                if (frame) {\r\n                    frames.push(frame);\r\n                }\r\n            });\r\n        }\r\n\r\n        this._triggerEvent('handle', {\r\n            stackInfo: stackInfo,\r\n            options: options\r\n        });\r\n\r\n        this._processException(\r\n            stackInfo.name,\r\n            stackInfo.message,\r\n            stackInfo.url,\r\n            stackInfo.lineno,\r\n            frames.slice(0, this._globalOptions.stackTraceLimit),\r\n            options\r\n        );\r\n    },\r\n\r\n    _normalizeFrame: function(frame) {\r\n        if (!frame.url) return;\r\n\r\n        // normalize the frames data\r\n        var normalized = {\r\n            filename:   frame.url,\r\n            lineno:     frame.line,\r\n            colno:      frame.column,\r\n            'function': frame.func || '?'\r\n        };\r\n\r\n        normalized.in_app = !( // determine if an exception came from outside of our app\r\n            // first we check the global includePaths list.\r\n            !!this._globalOptions.includePaths.test && !this._globalOptions.includePaths.test(normalized.filename) ||\r\n            // Now we check for fun, if the function name is Raven or TraceKit\r\n            /(Raven|TraceKit)\\./.test(normalized['function']) ||\r\n            // finally, we do a last ditch effort and check for raven.min.js\r\n            /raven\\.(min\\.)?js$/.test(normalized.filename)\r\n        );\r\n\r\n        return normalized;\r\n    },\r\n\r\n    _processException: function(type, message, fileurl, lineno, frames, options) {\r\n        var stacktrace, fullMessage;\r\n\r\n        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(message)) return;\r\n\r\n        message += '';\r\n        message = truncate(message, this._globalOptions.maxMessageLength);\r\n\r\n        fullMessage = (type ? type + ': ' : '') + message;\r\n        fullMessage = truncate(fullMessage, this._globalOptions.maxMessageLength);\r\n\r\n        if (frames && frames.length) {\r\n            fileurl = frames[0].filename || fileurl;\r\n            // Sentry expects frames oldest to newest\r\n            // and JS sends them as newest to oldest\r\n            frames.reverse();\r\n            stacktrace = {frames: frames};\r\n        } else if (fileurl) {\r\n            stacktrace = {\r\n                frames: [{\r\n                    filename: fileurl,\r\n                    lineno: lineno,\r\n                    in_app: true\r\n                }]\r\n            };\r\n        }\r\n\r\n        if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) return;\r\n        if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) return;\r\n\r\n        var data = objectMerge({\r\n            // sentry.interfaces.Exception\r\n            exception: {\r\n                values: [{\r\n                    type: type,\r\n                    value: message,\r\n                    stacktrace: stacktrace\r\n                }]\r\n            },\r\n            culprit: fileurl,\r\n            message: fullMessage\r\n        }, options);\r\n\r\n        // Fire away!\r\n        this._send(data);\r\n    },\r\n\r\n    _trimPacket: function(data) {\r\n        // For now, we only want to truncate the two different messages\r\n        // but this could/should be expanded to just trim everything\r\n        var max = this._globalOptions.maxMessageLength;\r\n        data.message = truncate(data.message, max);\r\n        if (data.exception) {\r\n            var exception = data.exception.values[0];\r\n            exception.value = truncate(exception.value, max);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    _getHttpData: function() {\r\n        if (!this._hasDocument || !document.location || !document.location.href) {\r\n            return;\r\n        }\r\n\r\n        var httpData = {\r\n            headers: {\r\n                'User-Agent': navigator.userAgent\r\n            }\r\n        };\r\n\r\n        httpData.url = document.location.href;\r\n\r\n        if (document.referrer) {\r\n            httpData.headers.Referer = document.referrer;\r\n        }\r\n\r\n        return httpData;\r\n    },\r\n\r\n\r\n    _send: function(data) {\r\n        var self = this;\r\n\r\n        var globalOptions = this._globalOptions;\r\n\r\n        var baseData = {\r\n            project: this._globalProject,\r\n            logger: globalOptions.logger,\r\n            platform: 'javascript'\r\n        }, httpData = this._getHttpData();\r\n\r\n        if (httpData) {\r\n            baseData.request = httpData;\r\n        }\r\n\r\n        data = objectMerge(baseData, data);\r\n\r\n        // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge\r\n        data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);\r\n        data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);\r\n\r\n        // Send along our own collected metadata with extra\r\n        data.extra['session:duration'] = now() - this._startTime;\r\n\r\n        if (this._breadcrumbs && this._breadcrumbs.length > 0) {\r\n            // intentionally make shallow copy so that additions\r\n            // to breadcrumbs aren't accidentally sent in this request\r\n            data.breadcrumbs = {\r\n                values: [].slice.call(this._breadcrumbs, 0)\r\n            };\r\n        }\r\n\r\n        // If there are no tags/extra, strip the key from the payload alltogther.\r\n        if (isEmptyObject(data.tags)) delete data.tags;\r\n\r\n        if (this._globalContext.user) {\r\n            // sentry.interfaces.User\r\n            data.user = this._globalContext.user;\r\n        }\r\n\r\n        // Include the release if it's defined in globalOptions\r\n        if (globalOptions.release) data.release = globalOptions.release;\r\n\r\n        // Include server_name if it's defined in globalOptions\r\n        if (globalOptions.serverName) data.server_name = globalOptions.serverName;\r\n\r\n        if (isFunction(globalOptions.dataCallback)) {\r\n            data = globalOptions.dataCallback(data) || data;\r\n        }\r\n\r\n        // Why??????????\r\n        if (!data || isEmptyObject(data)) {\r\n            return;\r\n        }\r\n\r\n        // Check if the request should be filtered or not\r\n        if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {\r\n            return;\r\n        }\r\n\r\n        // Send along an event_id if not explicitly passed.\r\n        // This event_id can be used to reference the error within Sentry itself.\r\n        // Set lastEventId after we know the error should actually be sent\r\n        this._lastEventId = data.event_id || (data.event_id = uuid4());\r\n\r\n        // Try and clean up the packet before sending by truncating long values\r\n        data = this._trimPacket(data);\r\n\r\n        this._logDebug('debug', 'Raven about to send:', data);\r\n\r\n        if (!this.isSetup()) return;\r\n\r\n        var auth = {\r\n            sentry_version: '7',\r\n            sentry_client: 'raven-js/' + this.VERSION,\r\n            sentry_key: this._globalKey\r\n        };\r\n        if (this._globalSecret) {\r\n            auth.sentry_secret = this._globalSecret;\r\n        }\r\n\r\n        this.captureBreadcrumb({\r\n            category: 'sentry',\r\n            message: data.message,\r\n            event_id: data.event_id\r\n        });\r\n\r\n        var url = this._globalEndpoint;\r\n        (globalOptions.transport || this._makeRequest).call(this, {\r\n            url: url,\r\n            auth: auth,\r\n            data: data,\r\n            options: globalOptions,\r\n            onSuccess: function success() {\r\n                self._triggerEvent('success', {\r\n                    data: data,\r\n                    src: url\r\n                });\r\n            },\r\n            onError: function failure() {\r\n                self._triggerEvent('failure', {\r\n                    data: data,\r\n                    src: url\r\n                });\r\n            }\r\n        });\r\n    },\r\n\r\n    _makeRequest: function(opts) {\r\n        var request = new XMLHttpRequest();\r\n\r\n        // if browser doesn't support CORS (e.g. IE7), we are out of luck\r\n        var hasCORS =\r\n            'withCredentials' in request ||\r\n            typeof XDomainRequest !== 'undefined';\r\n\r\n        if (!hasCORS) return;\r\n\r\n        var url = opts.url;\r\n        function handler() {\r\n            if (request.status === 200) {\r\n                if (opts.onSuccess) {\r\n                    opts.onSuccess();\r\n                }\r\n            } else if (opts.onError) {\r\n                opts.onError();\r\n            }\r\n        }\r\n\r\n        if ('withCredentials' in request) {\r\n            request.onreadystatechange = function () {\r\n                if (request.readyState !== 4) {\r\n                    return;\r\n                }\r\n                handler();\r\n            };\r\n        } else {\r\n            request = new XDomainRequest();\r\n            // xdomainrequest cannot go http -> https (or vice versa),\r\n            // so always use protocol relative\r\n            url = url.replace(/^https?:/, '');\r\n\r\n            // onreadystatechange not supported by XDomainRequest\r\n            request.onload = handler;\r\n        }\r\n\r\n        // NOTE: auth is intentionally sent as part of query string (NOT as custom\r\n        //       HTTP header) so as to avoid preflight CORS requests\r\n        request.open('POST', url + '?' + urlencode(opts.auth));\r\n        request.send(JSON.stringify(opts.data));\r\n    },\r\n\r\n    // Note: this is shitty, but I can't figure out how to get\r\n    // sinon to stub document.createElement without breaking everything\r\n    // so this wrapper is just so I can stub it for tests.\r\n    _newImage: function() {\r\n        return document.createElement('img');\r\n    },\r\n\r\n    _logDebug: function(level) {\r\n        if (this._originalConsoleMethods[level] && this.debug) {\r\n            // In IE<10 console methods do not have their own 'apply' method\r\n            Function.prototype.apply.call(\r\n                this._originalConsoleMethods[level],\r\n                this._originalConsole,\r\n                [].slice.call(arguments, 1)\r\n            );\r\n        }\r\n    },\r\n\r\n    _mergeContext: function(key, context) {\r\n        if (isUndefined(context)) {\r\n            delete this._globalContext[key];\r\n        } else {\r\n            this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);\r\n        }\r\n    }\r\n};\r\n\r\n// Deprecations\r\nRaven.prototype.setUser = Raven.prototype.setUserContext;\r\nRaven.prototype.setReleaseContext = Raven.prototype.setRelease;\r\n\r\nmodule.exports = Raven;\r\n\r\n},{\"1\":1,\"2\":2,\"5\":5,\"6\":6}],4:[function(_dereq_,module,exports){\r\n/**\r\n * Enforces a single instance of the Raven client, and the\r\n * main entry point for Raven. If you are a consumer of the\r\n * Raven library, you SHOULD load this file (vs raven.js).\r\n **/\r\n\r\n'use strict';\r\n\r\nvar RavenConstructor = _dereq_(3);\r\n\r\nvar _Raven = window.Raven;\r\n\r\nvar Raven = new RavenConstructor();\r\n\r\n/*\r\n * Allow multiple versions of Raven to be installed.\r\n * Strip Raven from the global context and returns the instance.\r\n *\r\n * @return {Raven}\r\n */\r\nRaven.noConflict = function () {\r\n\twindow.Raven = _Raven;\r\n\treturn Raven;\r\n};\r\n\r\nRaven.afterLoad();\r\n\r\nmodule.exports = Raven;\r\n\r\n},{\"3\":3}],5:[function(_dereq_,module,exports){\r\n/*eslint no-extra-parens:0*/\r\n'use strict';\r\n\r\nvar objectPrototype = Object.prototype;\r\n\r\nfunction isUndefined(what) {\r\n    return what === void 0;\r\n}\r\n\r\nfunction isFunction(what) {\r\n    return typeof what === 'function';\r\n}\r\n\r\nfunction isString(what) {\r\n    return objectPrototype.toString.call(what) === '[object String]';\r\n}\r\n\r\nfunction isObject(what) {\r\n    return typeof what === 'object' && what !== null;\r\n}\r\n\r\nfunction isEmptyObject(what) {\r\n    for (var _ in what) return false;  // eslint-disable-line guard-for-in, no-unused-vars\r\n    return true;\r\n}\r\n\r\n// Sorta yanked from https://github.com/joyent/node/blob/aa3b4b4/lib/util.js#L560\r\n// with some tiny modifications\r\nfunction isError(what) {\r\n    var toString = objectPrototype.toString.call(what);\r\n    return isObject(what) &&\r\n        toString === '[object Error]' ||\r\n        toString === '[object Exception]' || // Firefox NS_ERROR_FAILURE Exceptions\r\n        what instanceof Error;\r\n}\r\n\r\nfunction each(obj, callback) {\r\n    var i, j;\r\n\r\n    if (isUndefined(obj.length)) {\r\n        for (i in obj) {\r\n            if (hasKey(obj, i)) {\r\n                callback.call(null, i, obj[i]);\r\n            }\r\n        }\r\n    } else {\r\n        j = obj.length;\r\n        if (j) {\r\n            for (i = 0; i < j; i++) {\r\n                callback.call(null, i, obj[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction objectMerge(obj1, obj2) {\r\n    if (!obj2) {\r\n        return obj1;\r\n    }\r\n    each(obj2, function(key, value){\r\n        obj1[key] = value;\r\n    });\r\n    return obj1;\r\n}\r\n\r\nfunction truncate(str, max) {\r\n    return !max || str.length <= max ? str : str.substr(0, max) + '\\u2026';\r\n}\r\n\r\n/**\r\n * hasKey, a better form of hasOwnProperty\r\n * Example: hasKey(MainHostObject, property) === true/false\r\n *\r\n * @param {Object} host object to check property\r\n * @param {string} key to check\r\n */\r\nfunction hasKey(object, key) {\r\n    return objectPrototype.hasOwnProperty.call(object, key);\r\n}\r\n\r\nfunction joinRegExp(patterns) {\r\n    // Combine an array of regular expressions and strings into one large regexp\r\n    // Be mad.\r\n    var sources = [],\r\n        i = 0, len = patterns.length,\r\n        pattern;\r\n\r\n    for (; i < len; i++) {\r\n        pattern = patterns[i];\r\n        if (isString(pattern)) {\r\n            // If it's a string, we need to escape it\r\n            // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n            sources.push(pattern.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1'));\r\n        } else if (pattern && pattern.source) {\r\n            // If it's a regexp already, we want to extract the source\r\n            sources.push(pattern.source);\r\n        }\r\n        // Intentionally skip other cases\r\n    }\r\n    return new RegExp(sources.join('|'), 'i');\r\n}\r\n\r\nfunction urlencode(o) {\r\n    var pairs = [];\r\n    each(o, function(key, value) {\r\n        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n    });\r\n    return pairs.join('&');\r\n}\r\n\r\n// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\r\n// intentionally using regex and not <a/> href parsing trick because React Native and other\r\n// environments where DOM might not be available\r\nfunction parseUrl(url) {\r\n    var match = url.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\r\n    if (!match) return {};\r\n\r\n    // coerce to undefined values to empty string so we don't get 'undefined'\r\n    var query = match[6] || '';\r\n    var fragment = match[8] || '';\r\n    return {\r\n        protocol: match[2],\r\n        host: match[4],\r\n        path: match[5],\r\n        relative: match[5] + query + fragment // everything minus origin\r\n    };\r\n}\r\nfunction uuid4() {\r\n    var crypto = window.crypto || window.msCrypto;\r\n\r\n    if (!isUndefined(crypto) && crypto.getRandomValues) {\r\n        // Use window.crypto API if available\r\n        var arr = new Uint16Array(8);\r\n        crypto.getRandomValues(arr);\r\n\r\n        // set 4 in byte 7\r\n        arr[3] = arr[3] & 0xFFF | 0x4000;\r\n        // set 2 most significant bits of byte 9 to '10'\r\n        arr[4] = arr[4] & 0x3FFF | 0x8000;\r\n\r\n        var pad = function(num) {\r\n            var v = num.toString(16);\r\n            while (v.length < 4) {\r\n                v = '0' + v;\r\n            }\r\n            return v;\r\n        };\r\n\r\n        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) +\r\n        pad(arr[5]) + pad(arr[6]) + pad(arr[7]);\r\n    } else {\r\n        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\r\n        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n            var r = Math.random()*16|0,\r\n                v = c === 'x' ? r : r&0x3|0x8;\r\n            return v.toString(16);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Given a child DOM element, returns a query-selector statement describing that\r\n * and its ancestors\r\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\r\n * @param elem\r\n * @returns {string}\r\n */\r\nfunction htmlTreeAsString(elem) {\r\n    var MAX_TRAVERSE_HEIGHT = 5,\r\n        MAX_OUTPUT_LEN = 80,\r\n        out = [],\r\n        height = 0,\r\n        len = 0,\r\n        separator = ' > ',\r\n        sepLength = separator.length,\r\n        nextStr;\r\n\r\n    while (elem && height++ < MAX_TRAVERSE_HEIGHT) {\r\n\r\n        nextStr = htmlElementAsString(elem);\r\n        // bail out if\r\n        // - nextStr is the 'html' element\r\n        // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\r\n        //   (ignore this limit if we are on the first iteration)\r\n        if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {\r\n            break;\r\n        }\r\n\r\n        out.push(nextStr);\r\n\r\n        len += nextStr.length;\r\n        elem = elem.parentNode;\r\n    }\r\n\r\n    return out.reverse().join(separator);\r\n}\r\n\r\n/**\r\n * Returns a simple, query-selector representation of a DOM element\r\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\r\n * @param HTMLElement\r\n * @returns {string}\r\n */\r\nfunction htmlElementAsString(elem) {\r\n    var out = [],\r\n        className,\r\n        classes,\r\n        key,\r\n        attr,\r\n        i;\r\n\r\n    if (!elem || !elem.tagName) {\r\n        return '';\r\n    }\r\n\r\n    out.push(elem.tagName.toLowerCase());\r\n    if (elem.id) {\r\n        out.push('#' + elem.id);\r\n    }\r\n\r\n    className = elem.className;\r\n    if (className && isString(className)) {\r\n        classes = className.split(' ');\r\n        for (i = 0; i < classes.length; i++) {\r\n            out.push('.' + classes[i]);\r\n        }\r\n    }\r\n    var attrWhitelist = ['type', 'name', 'title', 'alt'];\r\n    for (i = 0; i < attrWhitelist.length; i++) {\r\n        key = attrWhitelist[i];\r\n        attr = elem.getAttribute(key);\r\n        if (attr) {\r\n            out.push('[' + key + '=\"' + attr + '\"]');\r\n        }\r\n    }\r\n    return out.join('');\r\n}\r\n\r\nmodule.exports = {\r\n    isUndefined: isUndefined,\r\n    isFunction: isFunction,\r\n    isString: isString,\r\n    isObject: isObject,\r\n    isEmptyObject: isEmptyObject,\r\n    isError: isError,\r\n    each: each,\r\n    objectMerge: objectMerge,\r\n    truncate: truncate,\r\n    hasKey: hasKey,\r\n    joinRegExp: joinRegExp,\r\n    urlencode: urlencode,\r\n    uuid4: uuid4,\r\n    htmlTreeAsString: htmlTreeAsString,\r\n    htmlElementAsString: htmlElementAsString,\r\n    parseUrl: parseUrl\r\n};\r\n\r\n},{}],6:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar utils = _dereq_(5);\r\n\r\nvar hasKey = utils.hasKey;\r\nvar isString = utils.isString;\r\nvar isUndefined = utils.isUndefined;\r\n\r\n/*\r\n TraceKit - Cross brower stack traces - github.com/occ/TraceKit\r\n MIT license\r\n*/\r\n\r\nvar TraceKit = {\r\n    collectWindowErrors: true,\r\n    debug: false\r\n};\r\n\r\n// global reference to slice\r\nvar _slice = [].slice;\r\nvar UNKNOWN_FUNCTION = '?';\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\r\nvar ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;\r\n\r\nfunction getLocationHref() {\r\n    if (typeof document === 'undefined')\r\n        return '';\r\n\r\n    return document.location.href;\r\n}\r\n\r\n/**\r\n * TraceKit.report: cross-browser processing of unhandled exceptions\r\n *\r\n * Syntax:\r\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\r\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\r\n *   TraceKit.report(exception)\r\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\r\n *\r\n * Supports:\r\n *   - Firefox: full stack trace with line numbers, plus column number\r\n *              on top frame; column number is not guaranteed\r\n *   - Opera:   full stack trace with line and column numbers\r\n *   - Chrome:  full stack trace with line and column numbers\r\n *   - Safari:  line and column number for the top frame only; some frames\r\n *              may be missing, and column number is not guaranteed\r\n *   - IE:      line and column number for the top frame only; some frames\r\n *              may be missing, and column number is not guaranteed\r\n *\r\n * In theory, TraceKit should work on all of the following versions:\r\n *   - IE5.5+ (only 8.0 tested)\r\n *   - Firefox 0.9+ (only 3.5+ tested)\r\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\r\n *     Exceptions Have Stacktrace to be enabled in opera:config)\r\n *   - Safari 3+ (only 4+ tested)\r\n *   - Chrome 1+ (only 5+ tested)\r\n *   - Konqueror 3.5+ (untested)\r\n *\r\n * Requires TraceKit.computeStackTrace.\r\n *\r\n * Tries to catch all unhandled exceptions and report them to the\r\n * subscribed handlers. Please note that TraceKit.report will rethrow the\r\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\r\n * If the exception does not reach the top of the browser, you will only\r\n * get a stack trace from the point where TraceKit.report was called.\r\n *\r\n * Handlers receive a stackInfo object as described in the\r\n * TraceKit.computeStackTrace docs.\r\n */\r\nTraceKit.report = (function reportModuleWrapper() {\r\n    var handlers = [],\r\n        lastArgs = null,\r\n        lastException = null,\r\n        lastExceptionStack = null;\r\n\r\n    /**\r\n     * Add a crash handler.\r\n     * @param {Function} handler\r\n     */\r\n    function subscribe(handler) {\r\n        installGlobalHandler();\r\n        handlers.push(handler);\r\n    }\r\n\r\n    /**\r\n     * Remove a crash handler.\r\n     * @param {Function} handler\r\n     */\r\n    function unsubscribe(handler) {\r\n        for (var i = handlers.length - 1; i >= 0; --i) {\r\n            if (handlers[i] === handler) {\r\n                handlers.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all crash handlers.\r\n     */\r\n    function unsubscribeAll() {\r\n        uninstallGlobalHandler();\r\n        handlers = [];\r\n    }\r\n\r\n    /**\r\n     * Dispatch stack information to all handlers.\r\n     * @param {Object.<string, *>} stack\r\n     */\r\n    function notifyHandlers(stack, isWindowError) {\r\n        var exception = null;\r\n        if (isWindowError && !TraceKit.collectWindowErrors) {\r\n          return;\r\n        }\r\n        for (var i in handlers) {\r\n            if (hasKey(handlers, i)) {\r\n                try {\r\n                    handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\r\n                } catch (inner) {\r\n                    exception = inner;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (exception) {\r\n            throw exception;\r\n        }\r\n    }\r\n\r\n    var _oldOnerrorHandler, _onErrorHandlerInstalled;\r\n\r\n    /**\r\n     * Ensures all global unhandled exceptions are recorded.\r\n     * Supported by Gecko and IE.\r\n     * @param {string} message Error message.\r\n     * @param {string} url URL of script that generated the exception.\r\n     * @param {(number|string)} lineNo The line number at which the error\r\n     * occurred.\r\n     * @param {?(number|string)} colNo The column number at which the error\r\n     * occurred.\r\n     * @param {?Error} ex The actual Error object.\r\n     */\r\n    function traceKitWindowOnError(message, url, lineNo, colNo, ex) {\r\n        var stack = null;\r\n\r\n        if (lastExceptionStack) {\r\n            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\r\n            processLastException();\r\n        } else if (ex) {\r\n            // New chrome and blink send along a real error object\r\n            // Let's just report that like a normal error.\r\n            // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\r\n            stack = TraceKit.computeStackTrace(ex);\r\n            notifyHandlers(stack, true);\r\n        } else {\r\n            var location = {\r\n                'url': url,\r\n                'line': lineNo,\r\n                'column': colNo\r\n            };\r\n\r\n            var name = undefined;\r\n            var msg = message; // must be new var or will modify original `arguments`\r\n            var groups;\r\n            if (isString(message)) {\r\n                var groups = message.match(ERROR_TYPES_RE);\r\n                if (groups) {\r\n                    name = groups[1];\r\n                    msg = groups[2];\r\n                }\r\n            }\r\n\r\n            location.func = UNKNOWN_FUNCTION;\r\n\r\n            stack = {\r\n                'name': name,\r\n                'message': msg,\r\n                'url': getLocationHref(),\r\n                'stack': [location]\r\n            };\r\n            notifyHandlers(stack, true);\r\n        }\r\n\r\n        if (_oldOnerrorHandler) {\r\n            return _oldOnerrorHandler.apply(this, arguments);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function installGlobalHandler ()\r\n    {\r\n        if (_onErrorHandlerInstalled) {\r\n            return;\r\n        }\r\n        _oldOnerrorHandler = window.onerror;\r\n        window.onerror = traceKitWindowOnError;\r\n        _onErrorHandlerInstalled = true;\r\n    }\r\n\r\n    function uninstallGlobalHandler ()\r\n    {\r\n        if (!_onErrorHandlerInstalled) {\r\n            return;\r\n        }\r\n        window.onerror = _oldOnerrorHandler;\r\n        _onErrorHandlerInstalled = false;\r\n        _oldOnerrorHandler = undefined;\r\n    }\r\n\r\n    function processLastException() {\r\n        var _lastExceptionStack = lastExceptionStack,\r\n            _lastArgs = lastArgs;\r\n        lastArgs = null;\r\n        lastExceptionStack = null;\r\n        lastException = null;\r\n        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\r\n    }\r\n\r\n    /**\r\n     * Reports an unhandled Error to TraceKit.\r\n     * @param {Error} ex\r\n     * @param {?boolean} rethrow If false, do not re-throw the exception.\r\n     * Only used for window.onerror to not cause an infinite loop of\r\n     * rethrowing.\r\n     */\r\n    function report(ex, rethrow) {\r\n        var args = _slice.call(arguments, 1);\r\n        if (lastExceptionStack) {\r\n            if (lastException === ex) {\r\n                return; // already caught by an inner catch block, ignore\r\n            } else {\r\n              processLastException();\r\n            }\r\n        }\r\n\r\n        var stack = TraceKit.computeStackTrace(ex);\r\n        lastExceptionStack = stack;\r\n        lastException = ex;\r\n        lastArgs = args;\r\n\r\n        // If the stack trace is incomplete, wait for 2 seconds for\r\n        // slow slow IE to see if onerror occurs or not before reporting\r\n        // this exception; otherwise, we will end up with an incomplete\r\n        // stack trace\r\n        window.setTimeout(function () {\r\n            if (lastException === ex) {\r\n                processLastException();\r\n            }\r\n        }, (stack.incomplete ? 2000 : 0));\r\n\r\n        if (rethrow !== false) {\r\n            throw ex; // re-throw to propagate to the top level (and cause window.onerror)\r\n        }\r\n    }\r\n\r\n    report.subscribe = subscribe;\r\n    report.unsubscribe = unsubscribe;\r\n    report.uninstall = unsubscribeAll;\r\n    return report;\r\n}());\r\n\r\n/**\r\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\r\n *\r\n * Syntax:\r\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\r\n * Returns:\r\n *   s.name              - exception name\r\n *   s.message           - exception message\r\n *   s.stack[i].url      - JavaScript or HTML file URL\r\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\r\n *   s.stack[i].args     - arguments passed to the function, if known\r\n *   s.stack[i].line     - line number, if known\r\n *   s.stack[i].column   - column number, if known\r\n *\r\n * Supports:\r\n *   - Firefox:  full stack trace with line numbers and unreliable column\r\n *               number on top frame\r\n *   - Opera 10: full stack trace with line and column numbers\r\n *   - Opera 9-: full stack trace with line numbers\r\n *   - Chrome:   full stack trace with line and column numbers\r\n *   - Safari:   line and column number for the topmost stacktrace element\r\n *               only\r\n *   - IE:       no line numbers whatsoever\r\n *\r\n * Tries to guess names of anonymous functions by looking for assignments\r\n * in the source code. In IE and Safari, we have to guess source file names\r\n * by searching for function bodies inside all page scripts. This will not\r\n * work for scripts that are loaded cross-domain.\r\n * Here be dragons: some function names may be guessed incorrectly, and\r\n * duplicate functions may be mismatched.\r\n *\r\n * TraceKit.computeStackTrace should only be used for tracing purposes.\r\n * Logging of unhandled exceptions should be done with TraceKit.report,\r\n * which builds on top of TraceKit.computeStackTrace and provides better\r\n * IE support by utilizing the window.onerror event to retrieve information\r\n * about the top of the stack.\r\n *\r\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\r\n * so computeStackTrace instead walks its *own* chain of callers.\r\n * This means that:\r\n *  * in Safari, some methods may be missing from the stack trace;\r\n *  * in IE, the topmost function in the stack trace will always be the\r\n *    caller of computeStackTrace.\r\n *\r\n * This is okay for tracing (because you are likely to be calling\r\n * computeStackTrace from the function you want to be the topmost element\r\n * of the stack trace anyway), but not okay for logging unhandled\r\n * exceptions (because your catch block will likely be far away from the\r\n * inner function that actually caused the exception).\r\n *\r\n */\r\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\r\n    /**\r\n     * Escapes special characters, except for whitespace, in a string to be\r\n     * used inside a regular expression as a string literal.\r\n     * @param {string} text The string.\r\n     * @return {string} The escaped string literal.\r\n     */\r\n    function escapeRegExp(text) {\r\n        return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\r\n    }\r\n\r\n    /**\r\n     * Escapes special characters in a string to be used inside a regular\r\n     * expression as a string literal. Also ensures that HTML entities will\r\n     * be matched the same as their literal friends.\r\n     * @param {string} body The string.\r\n     * @return {string} The escaped string.\r\n     */\r\n    function escapeCodeAsRegExpForMatchingInsideHTML(body) {\r\n        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\r\n    }\r\n\r\n    // Contents of Exception in various browsers.\r\n    //\r\n    // SAFARI:\r\n    // ex.message = Can't find variable: qq\r\n    // ex.line = 59\r\n    // ex.sourceId = 580238192\r\n    // ex.sourceURL = http://...\r\n    // ex.expressionBeginOffset = 96\r\n    // ex.expressionCaretOffset = 98\r\n    // ex.expressionEndOffset = 98\r\n    // ex.name = ReferenceError\r\n    //\r\n    // FIREFOX:\r\n    // ex.message = qq is not defined\r\n    // ex.fileName = http://...\r\n    // ex.lineNumber = 59\r\n    // ex.columnNumber = 69\r\n    // ex.stack = ...stack trace... (see the example below)\r\n    // ex.name = ReferenceError\r\n    //\r\n    // CHROME:\r\n    // ex.message = qq is not defined\r\n    // ex.name = ReferenceError\r\n    // ex.type = not_defined\r\n    // ex.arguments = ['aa']\r\n    // ex.stack = ...stack trace...\r\n    //\r\n    // INTERNET EXPLORER:\r\n    // ex.message = ...\r\n    // ex.name = ReferenceError\r\n    //\r\n    // OPERA:\r\n    // ex.message = ...message... (see the example below)\r\n    // ex.name = ReferenceError\r\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\r\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\r\n\r\n    /**\r\n     * Computes stack trace information from the stack property.\r\n     * Chrome and Gecko use this property.\r\n     * @param {Error} ex\r\n     * @return {?Object.<string, *>} Stack trace information.\r\n     */\r\n    function computeStackTraceFromStackProp(ex) {\r\n        if (isUndefined(ex.stack) || !ex.stack) return;\r\n\r\n        var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\r\n            gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|\\[native).*?)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\r\n            winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:ms-appx|https?|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\r\n            lines = ex.stack.split('\\n'),\r\n            stack = [],\r\n            parts,\r\n            element,\r\n            reference = /^(.*) is undefined$/.exec(ex.message);\r\n\r\n        for (var i = 0, j = lines.length; i < j; ++i) {\r\n            if ((parts = chrome.exec(lines[i]))) {\r\n                var isNative = parts[2] && parts[2].indexOf('native') !== -1;\r\n                element = {\r\n                    'url': !isNative ? parts[2] : null,\r\n                    'func': parts[1] || UNKNOWN_FUNCTION,\r\n                    'args': isNative ? [parts[2]] : [],\r\n                    'line': parts[3] ? +parts[3] : null,\r\n                    'column': parts[4] ? +parts[4] : null\r\n                };\r\n            } else if ( parts = winjs.exec(lines[i]) ) {\r\n                element = {\r\n                    'url': parts[2],\r\n                    'func': parts[1] || UNKNOWN_FUNCTION,\r\n                    'args': [],\r\n                    'line': +parts[3],\r\n                    'column': parts[4] ? +parts[4] : null\r\n                };\r\n            } else if ((parts = gecko.exec(lines[i]))) {\r\n                element = {\r\n                    'url': parts[3],\r\n                    'func': parts[1] || UNKNOWN_FUNCTION,\r\n                    'args': parts[2] ? parts[2].split(',') : [],\r\n                    'line': parts[4] ? +parts[4] : null,\r\n                    'column': parts[5] ? +parts[5] : null\r\n                };\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            if (!element.func && element.line) {\r\n                element.func = UNKNOWN_FUNCTION;\r\n            }\r\n\r\n            stack.push(element);\r\n        }\r\n\r\n        if (!stack.length) {\r\n            return null;\r\n        }\r\n\r\n        if (!stack[0].column && !isUndefined(ex.columnNumber)) {\r\n            // FireFox uses this awesome columnNumber property for its top frame\r\n            // Also note, Firefox's column number is 0-based and everything else expects 1-based,\r\n            // so adding 1\r\n            stack[0].column = ex.columnNumber + 1;\r\n        }\r\n\r\n        return {\r\n            'name': ex.name,\r\n            'message': ex.message,\r\n            'url': getLocationHref(),\r\n            'stack': stack\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Computes stack trace information from the stacktrace property.\r\n     * Opera 10 uses this property.\r\n     * @param {Error} ex\r\n     * @return {?Object.<string, *>} Stack trace information.\r\n     */\r\n    function computeStackTraceFromStacktraceProp(ex) {\r\n        // Access and store the stacktrace property before doing ANYTHING\r\n        // else to it because Opera is not very good at providing it\r\n        // reliably in other circumstances.\r\n        var stacktrace = ex.stacktrace;\r\n        if (isUndefined(ex.stacktrace) || !ex.stacktrace) return;\r\n\r\n        var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i,\r\n          opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i,\r\n          lines = stacktrace.split('\\n'),\r\n          stack = [],\r\n          parts;\r\n\r\n        for (var line = 0; line < lines.length; line += 2) {\r\n            var element = null;\r\n            if ((parts = opera10Regex.exec(lines[line]))) {\r\n                element = {\r\n                    'url': parts[2],\r\n                    'line': +parts[1],\r\n                    'column': null,\r\n                    'func': parts[3],\r\n                    'args':[]\r\n                };\r\n            } else if ((parts = opera11Regex.exec(lines[line]))) {\r\n                element = {\r\n                    'url': parts[6],\r\n                    'line': +parts[1],\r\n                    'column': +parts[2],\r\n                    'func': parts[3] || parts[4],\r\n                    'args': parts[5] ? parts[5].split(',') : []\r\n                };\r\n            }\r\n\r\n            if (element) {\r\n                if (!element.func && element.line) {\r\n                    element.func = UNKNOWN_FUNCTION;\r\n                }\r\n\r\n                stack.push(element);\r\n            }\r\n        }\r\n\r\n        if (!stack.length) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            'name': ex.name,\r\n            'message': ex.message,\r\n            'url': getLocationHref(),\r\n            'stack': stack\r\n        };\r\n    }\r\n\r\n    /**\r\n     * NOT TESTED.\r\n     * Computes stack trace information from an error message that includes\r\n     * the stack trace.\r\n     * Opera 9 and earlier use this method if the option to show stack\r\n     * traces is turned on in opera:config.\r\n     * @param {Error} ex\r\n     * @return {?Object.<string, *>} Stack information.\r\n     */\r\n    function computeStackTraceFromOperaMultiLineMessage(ex) {\r\n        // Opera includes a stack trace into the exception message. An example is:\r\n        //\r\n        // Statement on line 3: Undefined variable: undefinedFunc\r\n        // Backtrace:\r\n        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\r\n        //         undefinedFunc(a);\r\n        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\r\n        //           zzz(x, y, z);\r\n        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\r\n        //           yyy(a, a, a);\r\n        //   Line 1 of function script\r\n        //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\r\n        //   ...\r\n\r\n        var lines = ex.message.split('\\n');\r\n        if (lines.length < 4) {\r\n            return null;\r\n        }\r\n\r\n        var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\r\n            lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\r\n            lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\r\n            stack = [],\r\n            scripts = document.getElementsByTagName('script'),\r\n            parts;\r\n\r\n        for (var line = 2; line < lines.length; line += 2) {\r\n            var item = null;\r\n            if ((parts = lineRE1.exec(lines[line]))) {\r\n                item = {\r\n                    'url': parts[2],\r\n                    'func': parts[3],\r\n                    'args': [],\r\n                    'line': +parts[1],\r\n                    'column': null\r\n                };\r\n            } else if ((parts = lineRE2.exec(lines[line]))) {\r\n                item = {\r\n                    'url': parts[3],\r\n                    'func': parts[4],\r\n                    'args': [],\r\n                    'line': +parts[1],\r\n                    'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.\r\n                };\r\n                var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\r\n            } else if ((parts = lineRE3.exec(lines[line]))) {\r\n                var url = window.location.href.replace(/#.*$/, '');\r\n                item = {\r\n                    'url': url,\r\n                    'func': '',\r\n                    'args': [],\r\n                    'line': parts[1],\r\n                    'column': null\r\n                };\r\n            }\r\n\r\n            if (item) {\r\n                if (!item.func) {\r\n                    item.func = UNKNOWN_FUNCTION;\r\n                }\r\n\r\n                stack.push(item);\r\n            }\r\n        }\r\n\r\n        if (!stack.length) {\r\n            return null; // could not parse multiline exception message as Opera stack trace\r\n        }\r\n\r\n        return {\r\n            'name': ex.name,\r\n            'message': lines[0],\r\n            'url': getLocationHref(),\r\n            'stack': stack\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Adds information about the first frame to incomplete stack traces.\r\n     * Safari and IE require this to get complete data on the first frame.\r\n     * @param {Object.<string, *>} stackInfo Stack trace information from\r\n     * one of the compute* methods.\r\n     * @param {string} url The URL of the script that caused an error.\r\n     * @param {(number|string)} lineNo The line number of the script that\r\n     * caused an error.\r\n     * @param {string=} message The error generated by the browser, which\r\n     * hopefully contains the name of the object that caused the error.\r\n     * @return {boolean} Whether or not the stack information was\r\n     * augmented.\r\n     */\r\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\r\n        var initial = {\r\n            'url': url,\r\n            'line': lineNo\r\n        };\r\n\r\n        if (initial.url && initial.line) {\r\n            stackInfo.incomplete = false;\r\n\r\n            if (!initial.func) {\r\n                initial.func = UNKNOWN_FUNCTION;\r\n            }\r\n\r\n            if (stackInfo.stack.length > 0) {\r\n                if (stackInfo.stack[0].url === initial.url) {\r\n                    if (stackInfo.stack[0].line === initial.line) {\r\n                        return false; // already in stack trace\r\n                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\r\n                        stackInfo.stack[0].line = initial.line;\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            stackInfo.stack.unshift(initial);\r\n            stackInfo.partial = true;\r\n            return true;\r\n        } else {\r\n            stackInfo.incomplete = true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Computes stack trace information by walking the arguments.caller\r\n     * chain at the time the exception occurred. This will cause earlier\r\n     * frames to be missed but is the only way to get any stack trace in\r\n     * Safari and IE. The top frame is restored by\r\n     * {@link augmentStackTraceWithInitialElement}.\r\n     * @param {Error} ex\r\n     * @return {?Object.<string, *>} Stack trace information.\r\n     */\r\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\r\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\r\n            stack = [],\r\n            funcs = {},\r\n            recursion = false,\r\n            parts,\r\n            item,\r\n            source;\r\n\r\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\r\n            if (curr === computeStackTrace || curr === TraceKit.report) {\r\n                // console.log('skipping internal function');\r\n                continue;\r\n            }\r\n\r\n            item = {\r\n                'url': null,\r\n                'func': UNKNOWN_FUNCTION,\r\n                'line': null,\r\n                'column': null\r\n            };\r\n\r\n            if (curr.name) {\r\n                item.func = curr.name;\r\n            } else if ((parts = functionName.exec(curr.toString()))) {\r\n                item.func = parts[1];\r\n            }\r\n\r\n            if (typeof item.func === 'undefined') {\r\n              try {\r\n                item.func = parts.input.substring(0, parts.input.indexOf('{'));\r\n              } catch (e) { }\r\n            }\r\n\r\n            if (funcs['' + curr]) {\r\n                recursion = true;\r\n            }else{\r\n                funcs['' + curr] = true;\r\n            }\r\n\r\n            stack.push(item);\r\n        }\r\n\r\n        if (depth) {\r\n            // console.log('depth is ' + depth);\r\n            // console.log('stack is ' + stack.length);\r\n            stack.splice(0, depth);\r\n        }\r\n\r\n        var result = {\r\n            'name': ex.name,\r\n            'message': ex.message,\r\n            'url': getLocationHref(),\r\n            'stack': stack\r\n        };\r\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Computes a stack trace for an exception.\r\n     * @param {Error} ex\r\n     * @param {(string|number)=} depth\r\n     */\r\n    function computeStackTrace(ex, depth) {\r\n        var stack = null;\r\n        depth = (depth == null ? 0 : +depth);\r\n\r\n        try {\r\n            // This must be tried first because Opera 10 *destroys*\r\n            // its stacktrace property if you try to access the stack\r\n            // property first!!\r\n            stack = computeStackTraceFromStacktraceProp(ex);\r\n            if (stack) {\r\n                return stack;\r\n            }\r\n        } catch (e) {\r\n            if (TraceKit.debug) {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        try {\r\n            stack = computeStackTraceFromStackProp(ex);\r\n            if (stack) {\r\n                return stack;\r\n            }\r\n        } catch (e) {\r\n            if (TraceKit.debug) {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        try {\r\n            stack = computeStackTraceFromOperaMultiLineMessage(ex);\r\n            if (stack) {\r\n                return stack;\r\n            }\r\n        } catch (e) {\r\n            if (TraceKit.debug) {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        try {\r\n            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\r\n            if (stack) {\r\n                return stack;\r\n            }\r\n        } catch (e) {\r\n            if (TraceKit.debug) {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        return {\r\n            'name': ex.name,\r\n            'message': ex.message,\r\n            'url': getLocationHref()\r\n        };\r\n    }\r\n\r\n    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\r\n    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\r\n\r\n    return computeStackTrace;\r\n}());\r\n\r\nmodule.exports = TraceKit;\r\n\r\n},{\"5\":5}]},{},[4])(4)\r\n});"],"sourceRoot":"/source/"}