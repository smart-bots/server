{"version":3,"sources":["jquery.scrollTo.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.scrollTo.js","sourcesContent":["/*!\r\n * jQuery.scrollTo\r\n * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com\r\n * Licensed under MIT\r\n * http://flesler.blogspot.com/2007/10/jqueryscrollto.html\r\n * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery\r\n * @author Ariel Flesler\r\n * @version 2.1.2\r\n */\r\n;(function(factory) {\r\n\t'use strict';\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// AMD\r\n\t\tdefine(['jquery'], factory);\r\n\t} else if (typeof module !== 'undefined' && module.exports) {\r\n\t\t// CommonJS\r\n\t\tmodule.exports = factory(require('jquery'));\r\n\t} else {\r\n\t\t// Global\r\n\t\tfactory(jQuery);\r\n\t}\r\n})(function($) {\r\n\t'use strict';\r\n\r\n\tvar $scrollTo = $.scrollTo = function(target, duration, settings) {\r\n\t\treturn $(window).scrollTo(target, duration, settings);\r\n\t};\r\n\r\n\t$scrollTo.defaults = {\r\n\t\taxis:'xy',\r\n\t\tduration: 0,\r\n\t\tlimit:true\r\n\t};\r\n\r\n\tfunction isWin(elem) {\r\n\t\treturn !elem.nodeName ||\r\n\t\t\t$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;\r\n\t}\t\t\r\n\r\n\t$.fn.scrollTo = function(target, duration, settings) {\r\n\t\tif (typeof duration === 'object') {\r\n\t\t\tsettings = duration;\r\n\t\t\tduration = 0;\r\n\t\t}\r\n\t\tif (typeof settings === 'function') {\r\n\t\t\tsettings = { onAfter:settings };\r\n\t\t}\r\n\t\tif (target === 'max') {\r\n\t\t\ttarget = 9e9;\r\n\t\t}\r\n\r\n\t\tsettings = $.extend({}, $scrollTo.defaults, settings);\r\n\t\t// Speed is still recognized for backwards compatibility\r\n\t\tduration = duration || settings.duration;\r\n\t\t// Make sure the settings are given right\r\n\t\tvar queue = settings.queue && settings.axis.length > 1;\r\n\t\tif (queue) {\r\n\t\t\t// Let's keep the overall duration\r\n\t\t\tduration /= 2;\r\n\t\t}\r\n\t\tsettings.offset = both(settings.offset);\r\n\t\tsettings.over = both(settings.over);\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\t// Null target yields nothing, just like jQuery does\r\n\t\t\tif (target === null) return;\r\n\r\n\t\t\tvar win = isWin(this),\r\n\t\t\t\telem = win ? this.contentWindow || window : this,\r\n\t\t\t\t$elem = $(elem),\r\n\t\t\t\ttarg = target, \r\n\t\t\t\tattr = {},\r\n\t\t\t\ttoff;\r\n\r\n\t\t\tswitch (typeof targ) {\r\n\t\t\t\t// A number will pass the regex\r\n\t\t\t\tcase 'number':\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\tif (/^([+-]=?)?\\d+(\\.\\d+)?(px|%)?$/.test(targ)) {\r\n\t\t\t\t\t\ttarg = both(targ);\r\n\t\t\t\t\t\t// We are done\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Relative/Absolute selector\r\n\t\t\t\t\ttarg = win ? $(targ) : $(targ, elem);\r\n\t\t\t\t\t/* falls through */\r\n\t\t\t\tcase 'object':\r\n\t\t\t\t\tif (targ.length === 0) return;\r\n\t\t\t\t\t// DOMElement / jQuery\r\n\t\t\t\t\tif (targ.is || targ.style) {\r\n\t\t\t\t\t\t// Get the real position of the target\r\n\t\t\t\t\t\ttoff = (targ = $(targ)).offset();\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;\r\n\r\n\t\t\t$.each(settings.axis.split(''), function(i, axis) {\r\n\t\t\t\tvar Pos\t= axis === 'x' ? 'Left' : 'Top',\r\n\t\t\t\t\tpos = Pos.toLowerCase(),\r\n\t\t\t\t\tkey = 'scroll' + Pos,\r\n\t\t\t\t\tprev = $elem[key](),\r\n\t\t\t\t\tmax = $scrollTo.max(elem, axis);\r\n\r\n\t\t\t\tif (toff) {// jQuery / DOMElement\r\n\t\t\t\t\tattr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);\r\n\r\n\t\t\t\t\t// If it's a dom element, reduce the margin\r\n\t\t\t\t\tif (settings.margin) {\r\n\t\t\t\t\t\tattr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;\r\n\t\t\t\t\t\tattr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattr[key] += offset[pos] || 0;\r\n\r\n\t\t\t\t\tif (settings.over[pos]) {\r\n\t\t\t\t\t\t// Scroll to a fraction of its width/height\r\n\t\t\t\t\t\tattr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar val = targ[pos];\r\n\t\t\t\t\t// Handle percentage values\r\n\t\t\t\t\tattr[key] = val.slice && val.slice(-1) === '%' ?\r\n\t\t\t\t\t\tparseFloat(val) / 100 * max\r\n\t\t\t\t\t\t: val;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Number or 'number'\r\n\t\t\t\tif (settings.limit && /^\\d+$/.test(attr[key])) {\r\n\t\t\t\t\t// Check the limits\r\n\t\t\t\t\tattr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Don't waste time animating, if there's no need.\r\n\t\t\t\tif (!i && settings.axis.length > 1) {\r\n\t\t\t\t\tif (prev === attr[key]) {\r\n\t\t\t\t\t\t// No animation needed\r\n\t\t\t\t\t\tattr = {};\r\n\t\t\t\t\t} else if (queue) {\r\n\t\t\t\t\t\t// Intermediate animation\r\n\t\t\t\t\t\tanimate(settings.onAfterFirst);\r\n\t\t\t\t\t\t// Don't animate this axis again in the next iteration.\r\n\t\t\t\t\t\tattr = {};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tanimate(settings.onAfter);\r\n\r\n\t\t\tfunction animate(callback) {\r\n\t\t\t\tvar opts = $.extend({}, settings, {\r\n\t\t\t\t\t// The queue setting conflicts with animate()\r\n\t\t\t\t\t// Force it to always be true\r\n\t\t\t\t\tqueue: true,\r\n\t\t\t\t\tduration: duration,\r\n\t\t\t\t\tcomplete: callback && function() {\r\n\t\t\t\t\t\tcallback.call(elem, targ, settings);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t$elem.animate(attr, opts);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t// Max scrolling position, works on quirks mode\r\n\t// It only fails (not too badly) on IE, quirks mode.\r\n\t$scrollTo.max = function(elem, axis) {\r\n\t\tvar Dim = axis === 'x' ? 'Width' : 'Height',\r\n\t\t\tscroll = 'scroll'+Dim;\r\n\r\n\t\tif (!isWin(elem))\r\n\t\t\treturn elem[scroll] - $(elem)[Dim.toLowerCase()]();\r\n\r\n\t\tvar size = 'client' + Dim,\r\n\t\t\tdoc = elem.ownerDocument || elem.document,\r\n\t\t\thtml = doc.documentElement,\r\n\t\t\tbody = doc.body;\r\n\r\n\t\treturn Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);\r\n\t};\r\n\r\n\tfunction both(val) {\r\n\t\treturn $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };\r\n\t}\r\n\r\n\t// Add special hooks so that window scroll properties can be animated\r\n\t$.Tween.propHooks.scrollLeft = \r\n\t$.Tween.propHooks.scrollTop = {\r\n\t\tget: function(t) {\r\n\t\t\treturn $(t.elem)[t.prop]();\r\n\t\t},\r\n\t\tset: function(t) {\r\n\t\t\tvar curr = this.get(t);\r\n\t\t\t// If interrupt is true and user scrolled, stop animating\r\n\t\t\tif (t.options.interrupt && t._last && t._last !== curr) {\r\n\t\t\t\treturn $(t.elem).stop();\r\n\t\t\t}\r\n\t\t\tvar next = Math.round(t.now);\r\n\t\t\t// Don't waste CPU\r\n\t\t\t// Browsers don't render floating point scroll\r\n\t\t\tif (curr !== next) {\r\n\t\t\t\t$(t.elem)[t.prop](next);\r\n\t\t\t\tt._last = this.get(t);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// AMD requirement\r\n\treturn $scrollTo;\r\n});\r\n"],"sourceRoot":"/source/"}